# I. Load packages and define functions
# =====================================
library("tidyverse")   # because we can't stop using it anymore
library("magrittr")    # get the %<>% pipe
library("ggpubr") # combine plots -  http://www.sthda.com/english/articles/24-ggpubr-publication-ready-plots/81-ggplot2-easy-way-to-mix-multiple-graphs-on-the-same-page/
library("sf")           # simple feature objects
# library("ggrepel")     # to improve plot labels
#
# library("future.apply") # faster handling of large tables
# library("data.table")   # faster handling of large tables
#
# library("rmapshaper")   # simplify shape file layers
# library("ggsflabel")    # label simple feature in ggplot  https://github.com/yutannihilation/ggsflabel - possibly inluded in ggplot
#
# library("eulerr")       # to compare BRIUV and eDNA
# library("ggplotify")    # base R to Ggplot
#
# library("vegan")        # for NMDS
# library("indicspecies") # indicator species  - see citation below
#
# library("FactoMineR") # MCA
# library("explor")     # check MCA results in browser
# library("factoextra") # get MCA results summaries
#
# library("jpeg")   # read in jpeg images - see line ~840
# library("nVennR")
# library("UpSetR")    # Conway, J. R., Lex, A. & Gehlenborg, N. 2017 UpSetR: an R package for the
#                      # visualization of intersecting sets and their properties. Bioinformatics 33,
#                      # 2938?2940. (doi:10.1093/bioinformatics/btx364)
#                      #
#                      # documentation at https://rdrr.io/cran/UpSetR/man/upset.html - hard to follow
# get Euler objects for plotting
# ------------------------------
get_euler_object = function(level, tibl){
require("eulerr")
require("tidyverse")
require("magrittr")
# check if needed columns are in the input data
stopifnot(c("BRUV.OBS.PRES", "EDNA.OBS.PRES", "OBIS.OBS.PRES") %in% names(tibl))
stopifnot(level %in% c("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"))
# isolate realvant columns for summary
tibl %<>% select(SET.ID, BRUV.OBS.PRES, EDNA.OBS.PRES, OBIS.OBS.PRES, RESERVE.GROUP, RESERVE.GROUP.LOCATION, SUPERKINGDOM,  PHYLUM,  CLASS,  ORDER,  FAMILY,  GENUS, SPECIES) %>% distinct()
# sum up unique presences fr Euler plot
tibl %<>% group_by(get(level)) %>% summarise(eDNA = as.logical(sum(EDNA.OBS.PRES)),
BRUV = as.logical(sum(BRUV.OBS.PRES)),
OBIS = as.logical(sum(OBIS.OBS.PRES))
)
return(euler(tibl[ , 2:4]))
}
# get Euler Ggplots
# -----------------
get_euler_ggplot = function(level, euler_ob, plot_label = TRUE){
require("tidyverse")
require ("ggplotify")
# sanitize input
stopifnot( class(euler_ob)[1] == "euler")
stopifnot(level %in% c("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"))
euler_ggplot <- as.ggplot(
plot(euler_ob, quantities = list(type = c("counts", "percent"), font=3, round=2, cex=0.8), labels = list(font=1, cex=0.8))
) + {if(plot_label == TRUE) labs(subtitle = str_to_sentence(level))}
return(euler_ggplot)
}
# get a table with relevant columns for mapping
# ---------------------------------------------
#   (from full_biodiv or fish_biodiv )
get_sf_biodiv =  function(tibl){
require("tidyverse")
require("magrittr")
require("sf")
# define columns for mapping add input verification
cols <- c("SET.ID", "MH.GPS.LAT", "MH.PPS.LONG",  "RESERVE.GROUP", "RESERVE.GROUP.INSIDE",
"RESERVE.GROUP.LOCATION", "PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS",
"SPECIES", "ASV", "ABUNDANCE", "SAMPLE.TYPE", "BRUV.OBS.PRES", "EDNA.OBS.PRES", "OBIS.OBS.PRES")
stopifnot(cols %in% names(tibl))
# select relavant data fro mapping
tibl %<>% ungroup %>% select(all_of(cols)) %>% arrange(SET.ID)
# get simple feature df for mapping, define coordinates as WGS84 (degrees)
tibl %<>% st_as_sf(coords=c("MH.PPS.LONG","MH.GPS.LAT")) %>% st_set_crs(4326)
}
# get bounding box around an area defined by a variable (here default: RESERVE.GROUP.LOCATION)
# ------------------------------------------------------
# from https://stackoverflow.com/questions/54696440/create-polygons-representing-bounding-boxes-for-subgroups-using-sf
get_bbox_anyloc <- function(tibl, location = c("RESERVE.GROUP.LOCATION")){
require("tidyverse")
require("magrittr")
require("sf")
# sanitize input and
stopifnot( c(location, "MH.PPS.LONG", "MH.GPS.LAT") %in% names(tibl))
# helper function
calc_angle <- function(lon,lat) {
cent_lon <- mean(lon)
cent_lat <- mean(lat)
ang <- atan2(lat - cent_lat, lon - cent_lon)
return(ang)
}
# calculate bounding box
bbox <- tibl %>% group_by(across(location)) %>%
summarise(xmin = min(MH.PPS.LONG) -0.01 ,ymin = min(MH.GPS.LAT) -0.01, xmax=max(MH.PPS.LONG) +0.01,  ymax = max(MH.GPS.LAT) +0.01) %>%
gather(x,lon,c('xmin','xmax')) %>% gather(y,lat,c('ymin','ymax')) %>%
st_as_sf(coords=c('lon','lat'),crs=4326,remove=F) %>%
group_by(across(location)) %>% mutate(angle = calc_angle(lon,lat)) %>%
arrange(angle) %>% summarise(do_union=FALSE) %>% st_cast('POLYGON')
return(bbox)
}
# get hacked data frame for heat-map plotting
# --------------------------------------------
#  - isolate coordinates into seperate columns
#  - ass two crows matching mapping extend to extend plot
get_plot_df = function(sf_df, show_var = NULL) {
require("sf")
require("purrr")
require("magrittr")
stopifnot("sf" %in% class(sf_df))
sf_df %<>% mutate(lat = unlist(map(sf_df$geometry,2)),
lon = unlist(map(sf_df$geometry,1))
) %>% st_drop_geometry %>%
{if(!is.null(show_var)) filter(.,SAMPLE.TYPE == show_var) else .} %>%
add_row(tibble_row(lon = 600, lat = -5200, SAMPLE.TYPE = "eDNA")) %>%
add_row(tibble_row(lon = 700, lat = -5000, SAMPLE.TYPE = "eDNA"))
return(sf_df)
}
# aggregate discrete observation of either method ("BOTH.PRES") per sampling area (e.g.: "RESERVE.GROUP.LOCATION") on "GENUS" or species  level
#   https://stackoverflow.com/questions/16513827/summarizing-multiple-columns-with-data-table
#   used to get distance matrices in vegan and for numerical summaries
# get_taxon_matrix <- function(long_dt = long_table_dt , group_var = "RESERVE.GROUP.LOCATION", level = "GENUS") {
#
#   if (level == "GENUS") {
#     # aggregate dt for provided grouping variable
#     long_table_dt_agg_group_var_level <- long_dt[, lapply(.SD, sum, na.rm=TRUE), by=c(group_var, "SUPERKINGDOM",  "PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS"), .SDcols=c("BOTH.PRES") ]
#   } else if (level == "SPECIES") {
#     # aggregate dt for provided grouping variable
#     long_table_dt_agg_group_var_level <- long_dt[, lapply(.SD, sum, na.rm=TRUE), by=c(group_var, "SUPERKINGDOM",  "PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"), .SDcols=c("BOTH.PRES") ]
#   } else {
#     stop("Level needs to be set to either \"GENUS\" or \"SPECIES\"")
#   }
#
#   # cast matrix
#   taxon_matrix <- as.matrix(data.table::dcast(setDT(long_table_dt_agg_group_var_level), get(group_var)~get(level), value.var="BOTH.PRES", sum, fill=0), rownames=TRUE)
#   return(taxon_matrix)
#
# }
# II. Read in data
# ================
# check input data of previous script
system("open -a \"Microsoft Excel\" \"/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/tables/998_r_map_and_add_obis__full_data_raw.xlsx\"")
long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/998_r_map_and_add_obiss__full_data_raw.Rds")
# III. Read in and format data
# ============================
# - mark non-NZ species  **(possibly needs to be re-worked)**
# - split "fish" and "full" data
# - filter for data completeness **(possibly needs to be re-worked)**
# Mark non-NZ species  **(possibly needs to be re-worked)**
# ---------------------------------------------------------
#  16-Mar-2021 add asterisks ("*") to non-NZ species, and ("**") to non-fish (mammals and crustaceans)
#  after checking with list
#  Roberts, C., Stewart, A., Struthers, C., Barker, J. & Kortet, S. 2019 Checklist of the Fishes of New Zealand.
nonnz_fish <- c("Asterropteryx", "Banjos", "Benitochromis", "Bostrychus", "Bovichtus", "Caprodon", "Coptodon", "Engraulis", "Gobiesox", "Gymnoscopelus", "Helcogramma", "Microcanthus", "Opistognathus", "Phoxinus", "Sander", "Scobinichthys")
nonnz_othr <- c("Macroctopus", "Jasus", "Arctocephalus", "Balaenoptera", "Tursiops")
long_table %<>% mutate(GENUS =
case_when(GENUS %in% nonnz_fish ~ paste0(GENUS, "*"),
GENUS %in% nonnz_othr ~ paste0(GENUS, "**"),
TRUE ~ GENUS)
)
# Filter for data completeness **(possibly needs to be re-worked)**
# ------------------------------------------------------------------
# - not done yet -
# continue her after 7-Jul-2021:
# possibly get equivalent of BOTH.PRES
# ------------------------------
# function needs to
#   get presence / absence on a {taxonomic level} (SPECIES)
#   per a {location} (SET.ID  RESERVE.GROUP.LOCATION )
#   ? check data completeness  {all "1" in BRUV.OBS.PRES	EDNA.OBS.PRES	OBIS.OBS.PRES}
# Split "fish" and "full" data
# ----------------------------
full_biodiv <- long_table %>% distinct()
fish_biodiv <- long_table %>% distinct() %>% filter(CLASS %in% c("Actinopteri", "Chondrichthyes")) %>% filter(!(GENUS %in% c("Sardinops")))
# III. Get Euler plots
# ====================
# get euler analysis results for plotting / plot_label = TRUE shrinks plots a lot
euler_obs_full_bio <- lapply(list("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"), get_euler_object, full_biodiv)
euler_ggp_full_bio <- mapply(get_euler_ggplot, list("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"),  euler_obs_full_bio, plot_label = FALSE, SIMPLIFY = FALSE)
# plot euler analysis results
euler_obs_fish_bio <- lapply(list("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"), get_euler_object, fish_biodiv)
euler_ggp_fish_bio <- mapply(get_euler_ggplot, list("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES"),  euler_obs_fish_bio, plot_label = FALSE, SIMPLIFY = FALSE)
# create compound plot with better labels then with plot_label = TRUE above
ggarrange(
ggarrange(plotlist = euler_ggp_full_bio,  ncol = 1, nrow = 6,
labels = str_to_sentence(c("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES")),
font.label = list(size = 12, color = "black", face = "bold.italic", family = NULL),
vjust = 4.5
),
ggarrange(plotlist = euler_ggp_fish_bio,  ncol = 1, nrow = 6), ncol = 2,
labels = c("a","b")
)
# save compound plot with better labels then with plot_label = TRUE above
ggsave("210712_998_r_summarize_results__euler_edna_bruv_obis.pdf", plot = last_plot(),
device = "pdf", path = "/Users/paul/Documents/OU_eDNA/200403_manuscript/3_main_figures_and_tables_components",
scale = 1.5, width = 75, height = 175, units = c("mm"),
dpi = 500, limitsize = TRUE)
ggarrange(
ggarrange(plotlist = euler_ggp_full_bio,  ncol = 1, nrow = 6,
labels = str_to_sentence(c("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES")),
font.label = list(size = 12, color = "black", face = "bold.italic", family = NULL),
vjust = 4.5
),
ggarrange(plotlist = euler_ggp_fish_bio,  ncol = 1, nrow = 6), ncol = 2,
labels = c("a","b")
)
# save compound plot with better labels then with plot_label = TRUE above
ggsave("210712_998_r_summarize_results__euler_edna_bruv_obis.pdf", plot = last_plot(),
device = "pdf", path = "/Users/paul/Documents/OU_eDNA/200403_manuscript/3_main_figures_and_tables_components",
scale = 1.5, width = 75, height = 175, units = c("mm"),
dpi = 500, limitsize = TRUE)
# IV. get geographical maps with heat overlays
# =============================================
# compare script  ~/Documents/OU_eDNA/200901_scripts/998_r_map_and_add_obis.r
# data preparation
# ----------------
# for mapping: get column-subset sf's with WGS 84 in degrees
full_biodiv_sf <- get_sf_biodiv(full_biodiv)
fish_biodiv_sf <- get_sf_biodiv(fish_biodiv)
# for mapping: get map layers
nzshp_hires_WGS84_sf <- read_sf("/Users/paul/GIS/NZ_coast/NZ_Coast_isl.shp") %>% st_transform(crs = 4326)
nzshp_lores_WGS84_sf <- rmapshaper::ms_simplify(input = as(nzshp_hires_WGS84_sf, 'Spatial')) %>% st_as_sf
# for mapping: define bounding boxes as in map in previous script
#  field work area & sample groups
bbox_fwork <- st_as_sfc(st_bbox(c(xmin = (166.5-0.1), xmax = (167.0+0.1), ymax = (-46.04-0.1), ymin = (-45.52+0.1)), crs = st_crs(4326)))
#  boxes around default value RESERVE.GROUP.LOCATION
bbox_rgl_full_biodiv <- get_bbox_anyloc(full_biodiv) # must use original object, not sf
bbox_rgl_fish_biodiv <- get_bbox_anyloc(fish_biodiv) # must use original object, not sf
# for mapping and buffer calculations at correct scale: re-project all sf's to local km
get_reprojection <- function(sf) st_transform(sf, crs = st_crs("+proj=utm +zone=58G +datum=WGS84 +units=km"))
full_biodiv_sf_km <- get_reprojection(full_biodiv_sf)
fish_biodiv_sf_km <- get_reprojection(fish_biodiv_sf)
nzshp_hires_WGS84_sf_km <- get_reprojection(nzshp_hires_WGS84_sf)
nzshp_lores_WGS84_sf_km <- get_reprojection(nzshp_lores_WGS84_sf)
bbox_fwork_km <- get_reprojection(bbox_fwork)
bbox_rgl_full_biodiv_km <- get_reprojection(bbox_rgl_full_biodiv)
bbox_rgl_fish_biodiv_km <- get_reprojection(bbox_rgl_fish_biodiv)
# calculate 2.5 km buffers
full_biodiv_sf_km_sid_buff <- full_biodiv_sf_km %>% select("SET.ID") %>% distinct %>% st_buffer(2.5)
fish_biodiv_sf_km_sid_buff <- fish_biodiv_sf_km %>% select("SET.ID") %>% distinct %>% st_buffer(2.5)
# get dataframes suitable for plotting with below functions - write as function
full_biodiv_df_edna <- get_plot_df(full_biodiv_sf_km, "eDNA")
full_biodiv_df_bruv <- get_plot_df(full_biodiv_sf_km, "BRUV")
full_biodiv_df_obis <- get_plot_df(full_biodiv_sf_km, "OBIS")
fish_biodiv_df_edna <- get_plot_df(fish_biodiv_sf_km, "eDNA")
fish_biodiv_df_edna <- get_plot_df(fish_biodiv_sf_km, "BRUV")
fish_biodiv_df_edna <- get_plot_df(fish_biodiv_sf_km, "OBIS")
get_ggeom_density(get_plot_df(fish_biodiv_sf_km))
get_ggeom_density(get_plot_df(fish_biodiv_sf_km, c("eDNA")))
get_ggeom_density(get_plot_df(fish_biodiv_sf_km, c("BRUV")))
get_ggeom_density(get_plot_df(fish_biodiv_sf_km, c("OBIS")))
map_inset <-  ggplot(data = nzshp_lores_WGS84_sf) + geom_sf(fill = "grey93", color = "red", lwd = 0.5) +
geom_sf(data = bbox_fwork, fill = NA, color = "darkred", size = 1) + theme_void()
plot_full_biodiv <- ggplot() +
geom_density_2d_filled(data = get_plot_df(full_biodiv_sf_km), aes(x= lon , y = lat), contour_var = "count", alpha = 0.5) +
facet_grid(. ~ SAMPLE.TYPE) +
geom_sf(data = nzshp_lores_WGS84_sf_km, color=alpha("grey20",1), alpha = 0.8) +
# geom_sf(data = fish_biodiv_sf_km_sid_buff, fill = NA, colour = "darkgrey") +
stat_sf_coordinates(data = full_biodiv_sf_km, aes(shape = RESERVE.GROUP), color = "grey20", size = 2) +
stat_sf_coordinates(data = full_biodiv_sf_km, aes(shape = RESERVE.GROUP), color = "white", size = 1) +
coord_sf(xlim = c((619.6011-10), (653.8977+10)), ylim = c((-5100.241-10),(-5042.894+10)) , expand = FALSE) +
theme_bw() +
theme(legend.position= "none",
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
plot_fish_biodiv <- ggplot() +
geom_density_2d_filled(data = get_plot_df(fish_biodiv_sf_km), aes(x= lon , y = lat), contour_var = "count", alpha = 0.5) +
facet_grid(. ~ SAMPLE.TYPE) +
geom_sf(data = nzshp_lores_WGS84_sf_km, color=alpha("grey20",1), alpha = 0.8) +
# geom_sf(data = fish_biodiv_sf_km_sid_buff, fill = NA, colour = "darkgrey") +
stat_sf_coordinates(data = fish_biodiv_sf_km, aes(shape = RESERVE.GROUP), color = "grey20", size = 2) +
stat_sf_coordinates(data = fish_biodiv_sf_km, aes(shape = RESERVE.GROUP), color = "white", size = 1) +
coord_sf(xlim = c((619.6011-10), (653.8977+10)), ylim = c((-5100.241-10),(-5042.894+10)) , expand = FALSE) +
theme_bw() +
theme(legend.position= "none",
axis.text.x = element_blank(),
axis.text.y = element_blank(),
axis.ticks.x = element_blank(),
axis.ticks.y = element_blank(),
axis.title.x = element_blank(),
axis.title.y = element_blank(),
panel.grid.major = element_blank(),
panel.grid.minor = element_blank()
)
ggarrange( plot_full_biodiv, plot_fish_biodiv,
ncol = 1, nrow = 2, labels = c("a","b") )
# save compound plot with better labels then with plot_label = TRUE above
ggsave("210712_998_r_summarize_results__geoheat_edna_bruv_obis.pdf", plot = last_plot(),
device = "pdf", path = "/Users/paul/Documents/OU_eDNA/200403_manuscript/3_main_figures_and_tables_components",
scale = 2, width = 85, height = 85, units = c("mm"),
dpi = 500, limitsize = TRUE)
full_biodiv  %>% select("PHYLUM",  "CLASS",  "ORDER",  "FAMILY",  "GENUS", "SPECIES") %>% distinct()
full_biodiv
fish_biodiv$NCBI.TAXID
#   **************************************************
#   * Combine, filter, and inspect long tables from  *
#   *   from eDNA data and BRUV observations         *
#   **************************************************
#   26-Feb-2021, 1-Mar-2021, 7-Jul-2021, 15-Jul-2021
# I. Load packages
# ================
rm(list = ls(all.names = TRUE))
lapply(paste('package:',names(sessionInfo()$otherPkgs),sep=""),detach,character.only=TRUE,unload=TRUE)
gc()
library("tidyverse")   # tibbles, pipes, and more
library("magrittr") # more pipes
library("robis")       # access OBIS data
library("readxl")      # read Excel files
library("openxlsx")    # write Excel tables
options(tibble.print_max = Inf)
# II. Functions
# =============
# Define new operator "not in"
"%!in%" <- function(x, y) !(x %in% y)
# III. Combine data
# =================
# load data
# ----------
# eDNA data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/990_r_get_eDNA_long_table.r"
edna_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/R_objects/210301_990_r_get_eDNA_long_table__eDNA_data.Rds")
# BRUV data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_BRUV_long_table.r"
bruv_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210226_995_r_get_BRUV_long_table__mh_bruv_obs.Rds")
# PUBL data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_PUBL_long_table.r"
publ_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210723_995_r_get_PUBL_long_table__publ_obs.Rds")
stack_long_table <- bind_rows(edna_long_table, bruv_long_table, publ_long_table)
dim(stack_long_table) #  466 x 67
names(stack_long_table)
stack_long_table <- stack_long_table %>% arrange(SET.ID)
# need to have three or two UNIQ.REP.IDS, otherwise can't analyse data
#   7-Jul-21:
#     practically this is keeping only sets with complete eDNA and Bruv observations
#     also check /Users/paul/Documents/OU_eDNA/200901_scripts/998_r_map_and_add_obis.r,
#     reused there to set the  UNIQ.REP.IDS, but no re-filtering applied
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% mutate(UNIQ.REP.IDS = n_distinct(REP.ID))
stack_long_table <- stack_long_table %>% filter(UNIQ.REP.IDS %in% c(2,3))
# among three or two UNIQ.REP.IDS needs to be on REP.ID = 3 (BRUV data) otherwise can't analyse
stack_long_table <- stack_long_table %>% filter(any(REP.ID == 3))
# sorting and inspection for sanity reasons
stack_long_table <- stack_long_table %>% arrange(desc(UNIQ.REP.IDS), SET.ID, REP.ID)
# works now:
# SET.ID: data set labels
# REP.ID: replicate identifiers (of which "3", marks lines with BRUV data)
# rearrange columns
stack_long_table <-  stack_long_table %>% relocate(SET.ID,	REP.ID, LOC.NAME, INSIDE.RESERVE,  MH.GPS.LAT,	MH.PPS.LONG,  SUPERKINGDOM,	PHYLUM,	CLASS,	ORDER,	FAMILY,	GENUS,	SPECIES)
# fill missing values for analysis
stack_long_table %>% group_by(SET.ID) %>% print(n = Inf)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(LOC.NAME) %>% print(n = Inf)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(INSIDE.RESERVE) %>% print(n = Inf)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(MH.GPS.LAT, .direction = c("downup")) %>% print(n = Inf)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(MH.PPS.LONG, .direction = c("downup")) %>% print(n = Inf)
# eDNA data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/990_r_get_eDNA_long_table.r"
edna_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/R_objects/210301_990_r_get_eDNA_long_table__eDNA_data.Rds")
# BRUV data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_BRUV_long_table.r"
bruv_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210226_995_r_get_BRUV_long_table__mh_bruv_obs.Rds")
# PUBL data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_PUBL_long_table.r"
publ_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210723_995_r_get_PUBL_long_table__publ_obs.Rds")
publ_long_table
stack_long_table <- bind_rows(edna_long_table, bruv_long_table, publ_long_table)
stack_long_table
dim(stack_long_table) #  466 x 67
names(stack_long_table)
stack_long_table <- stack_long_table %>% arrange(SET.ID)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% mutate(UNIQ.REP.IDS = n_distinct(REP.ID))
stack_long_table <- stack_long_table %>% filter(UNIQ.REP.IDS %in% c(2,3))
stack_long_table <- stack_long_table %>% filter(any(REP.ID == 3))
stack_long_table <- stack_long_table %>% arrange(desc(UNIQ.REP.IDS), SET.ID, REP.ID)
stack_long_table
# works now:
# SET.ID: data set labels
# REP.ID: replicate identifiers (of which "3", marks lines with BRUV data)
# rearrange columns
stack_long_table <-  stack_long_table %>% relocate(SET.ID,	REP.ID, LOC.NAME, INSIDE.RESERVE,  MH.GPS.LAT,	MH.PPS.LONG,  SUPERKINGDOM,	PHYLUM,	CLASS,	ORDER,	FAMILY,	GENUS,	SPECIES)
stack_long_table
rm(list = ls(all.names = TRUE))
gc()
library("tidyverse")   # tibbles, pipes, and more
library("magrittr") # more pipes
library("robis")       # access OBIS data
library("readxl")      # read Excel files
library("openxlsx")    # write Excel tables
options(tibble.print_max = Inf)
# II. Functions
# =============
# Define new operator "not in"
"%!in%" <- function(x, y) !(x %in% y)
# III. Combine data
# =================
# load data
# ----------
# eDNA data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/990_r_get_eDNA_long_table.r"
edna_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/R_objects/210301_990_r_get_eDNA_long_table__eDNA_data.Rds")
# BRUV data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_BRUV_long_table.r"
bruv_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210226_995_r_get_BRUV_long_table__mh_bruv_obs.Rds")
# PUBL data by  "/Users/paul/Documents/OU_eDNA/200901_scripts/995_r_get_PUBL_long_table.r"
publ_long_table <- readRDS(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210723_995_r_get_PUBL_long_table__publ_obs.Rds")
# stack data
# ----------
stack_long_table <- bind_rows(edna_long_table, bruv_long_table)
dim(stack_long_table) #  466 x 67
names(stack_long_table)
# IV. Format data
# ===============
# sorting and inspection for sanity reasons
stack_long_table <- stack_long_table %>% arrange(SET.ID)
# need to have three or two UNIQ.REP.IDS, otherwise can't analyse data
#   7-Jul-21:
#     practically this is keeping only sets with complete eDNA and Bruv observations
#     also check /Users/paul/Documents/OU_eDNA/200901_scripts/998_r_map_and_add_obis.r,
#     reused there to set the  UNIQ.REP.IDS, but no re-filtering applied
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% mutate(UNIQ.REP.IDS = n_distinct(REP.ID))
stack_long_table <- stack_long_table %>% filter(UNIQ.REP.IDS %in% c(2,3))
# among three or two UNIQ.REP.IDS needs to be on REP.ID = 3 (BRUV data) otherwise can't analyse
stack_long_table <- stack_long_table %>% filter(any(REP.ID == 3))
# sorting and inspection for sanity reasons
stack_long_table <- stack_long_table %>% arrange(desc(UNIQ.REP.IDS), SET.ID, REP.ID)
# works now:
# SET.ID: data set labels
# REP.ID: replicate identifiers (of which "3", marks lines with BRUV data)
# rearrange columns
stack_long_table <-  stack_long_table %>% relocate(SET.ID,	REP.ID, LOC.NAME, INSIDE.RESERVE,  MH.GPS.LAT,	MH.PPS.LONG,  SUPERKINGDOM,	PHYLUM,	CLASS,	ORDER,	FAMILY,	GENUS,	SPECIES)
# fill missing values for analysis
stack_long_table %>% group_by(SET.ID) %>% print(n = Inf)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(LOC.NAME)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(INSIDE.RESERVE)
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(MH.GPS.LAT, .direction = c("downup"))
stack_long_table <- stack_long_table %>% group_by(SET.ID) %>% fill(MH.PPS.LONG, .direction = c("downup"))
# V. Redefine areas inside and out side marine reserves
# ========================================================
# done using GID externally - check `/Users/paul/Documents/OU_eDNA/200403_manuscript/6_analysis_notes/210301_sample_map_overview.pdf`
# see subsequent script for site assignments - but not run here to maintain compatibility with MdL scripts
#  long_table <- long_table %>% mutate( RESERVE.GROUP = case_when(RESERVE.GROUP == "A" ~ "WJ", RESERVE.GROUP == "B" ~ "FF", RESERVE.GROUP == "C" ~ "LS"))
stack_long_table <- stack_long_table %>% mutate(RESERVE.GROUP =
case_when(SET.ID %in% c(21,22,23,24) ~ "A",
SET.ID %in% c(26,27,28,29) ~ "A",
SET.ID %in% c(11,12)       ~ "B",
SET.ID %in% c(17,18,19)    ~ "B",
SET.ID %in% c(7,8,9,10)    ~ "C",
SET.ID %in% c(1,3,4,5)     ~ "C"))
stack_long_table <- stack_long_table %>% mutate(RESERVE.GROUP.INSIDE =
case_when(SET.ID %in% c(21,22,23,24) ~ TRUE,
SET.ID %in% c(26,27,28,29)  ~ FALSE,
SET.ID %in% c(11,12)       ~ TRUE,
SET.ID %in% c(17,18,19)    ~ FALSE,
SET.ID %in% c(7,8,9,10)    ~ FALSE,
SET.ID %in% c(1,3,4,5)     ~ TRUE))
long_table <- stack_long_table %>% mutate(SAMPLE.TYPE = case_when(REP.ID %in% c(3)   ~  "BRUV",
REP.ID %in% c(1,2) ~  SAMPLE.TYPE))
# correct location name in fulls table
long_table <- long_table %>% mutate( RESERVE.GROUP = case_when(RESERVE.GROUP == "A" ~ "WJ", RESERVE.GROUP == "B" ~ "FF", RESERVE.GROUP == "C" ~ "LS"))
# remove three undetermined fish taxa from BRUV
long_table <- long_table %>% filter(ORDER != "NA") %>% print(n = Inf)
# combine RESERVE.GROUP and RESERVE.GROUP.INSIDE to get six locations RESERVE.GROUP.LOCATION
long_table$RESERVE.GROUP
long_table$RESERVE.GROUP.INSIDE
long_table <- long_table %>% mutate( RESERVE.GROUP.LOCATION =
case_when(RESERVE.GROUP == "WJ" & RESERVE.GROUP.INSIDE == TRUE  ~ "WJ MR",
RESERVE.GROUP == "WJ" & RESERVE.GROUP.INSIDE == FALSE ~ "WJ CTRL",
RESERVE.GROUP == "FF" & RESERVE.GROUP.INSIDE == TRUE  ~ "FF MR",
RESERVE.GROUP == "FF" & RESERVE.GROUP.INSIDE == FALSE ~ "FF CTRL",
RESERVE.GROUP == "LS" & RESERVE.GROUP.INSIDE == TRUE  ~ "LS MR",
RESERVE.GROUP == "LS" & RESERVE.GROUP.INSIDE == FALSE ~ "LS CTRL")
)
long_table$RESERVE.GROUP.LOCATION
long_table <- long_table %>% relocate(RESERVE.GROUP.LOCATION)
# set BRUV observations to 1 for downstream generation of ASV presence column
long_table <- long_table %>% mutate(ABUNDANCE =
case_when(SAMPLE.TYPE == "BRUV" & is.na(ABUNDANCE) ~ 1,
TRUE ~ ABUNDANCE)
)
# rearrange columns
long_table <-  long_table %>% relocate(SET.ID,	REP.ID, SAMPLE.TYPE, LOC.NAME, MH.GPS.LAT,
MH.PPS.LONG, RESERVE.GROUP,  RESERVE.GROUP.INSIDE, RESERVE.GROUP.LOCATION, SUPERKINGDOM,
PHYLUM,	CLASS,	ORDER,	FAMILY,	GENUS,	SPECIES)
print(long_table)
# VI. Insert 15-Jul-2021 - add NCBI data in (had been lost)
# ==========================================================
# check relavant columns - NCBI.TAXID needs to be filled (again) for eDNA data
long_table |> select(SAMPLE.TYPE, ASV, NCBI.TAXID)
# load "blast_results_final" to get access to the "tax_id" column looked up previously
load(file="/Users/paul/Documents/OU_eDNA/201028_Robjects/210202_get_q2_tax-tab__blast-noenv_with-ncbi_taxonomy.Rdata")
blast_results_final |> select(iteration_query_def, tax_id)
# fill in missing NCBI tax strings
long_table <- long_table |>
left_join( {blast_results_final |> select(iteration_query_def, tax_id) |> setNames(c("ASV", "NCBI.TAXID"))} , by = c("ASV")) |>
unite(NCBI.TAXID, c(NCBI.TAXID.x, NCBI.TAXID.y), remove = TRUE, na.rm = TRUE) # |>
# select(SAMPLE.TYPE, ASV, NCBI.TAXID)
# VIII. Insert 23-Jul-2021 - add Publication data
# ==============================================
# for superseded QGIS mapping in /Users/paul/Documents/OU_eDNA/200403_manuscript/3_main_figures_and_tables_components/210307_sample_map.qgz
write.csv(long_table, "/Users/paul/Documents/OU_eDNA/200403_manuscript/3_main_figures_and_tables_components/210301_997_r_format_longtables__analysis_input.csv")
long_table <- bind_rows(long_table, publ_long_table)
long_table <- bind_rows({long_table |> mutate(NCBI.TAXID = as.numeric(NCBI.TAXID)}, publ_long_table)
long_table <- bind_rows( {long_table |> mutate(NCBI.TAXID = as.numeric(NCBI.TAXID))}, publ_long_table)
long_table
dim(long_table) # 267 x 71
save.image(file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210301_997_r_format_longtables__analysis_input__image.Rdata")
save.image(file = "/Users/paul/Documents/OU_eDNA/210705_r_workspaces/210301_997_r_format_longtables__analysis_input__image.Rdata")
# for verbosity
write.xlsx(long_table, "/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/tables/210301_997_r_format_longtables__analysis_input.xlsx", asTable = FALSE, overwrite = TRUE)
# for previous analysis by MDL
saveRDS(long_table, file = "/Users/paul/Documents/OU_eDNA/201028_Robjects/210301_997_r_format_longtables__analysis_input.Rds")
saveRDS(long_table, file = "/Users/paul/Documents/OU_eDNA/200403_manuscript/5_online_repository/R_objects/210301_997_r_format_longtables__analysis_input.Rds")
